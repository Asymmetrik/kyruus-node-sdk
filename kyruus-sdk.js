'use strict';
const https = require('https'),
	crypto = require('crypto'),
	q = require('q'),
	_ = require('lodash');

const k = require('./query-builder.js');

const {
	KyruusFacet,
	KyruusGeoCode,
	KyruusLocation,
	KyruusProvider,
	KyruusProviderSearch,
	KyruusSuggestions,
	KyruusSuggestionData,
	KyruusTypeAheadObject,
	KyruusTypeAhead
} = require('./data');


/**
 * Default request options for Kyruus search
 * @typedef {Object} DefaultSearchOptions
 * @property {string} hostname - root url of the target endpoint
 * @property {number} [port=443] port - target port
 * @property {string} [method=GET] method - Target restful method
 * @property {string} [headers.Authorization] - Auth key for the query
 */

class Kyruus {
	get version() {
		return 'v8';
	}

	constructor(endpoint = '', source = '', user = '', password = '') {
		this.endpoint = endpoint;
		this.source = source;
		this._userName = user;
		this._userPassword = password;

		this._token = undefined;
		this._expiresAt = 0;
		this._refreshTokenLock = null;
	}

	/**
	 * @function __getTimeInSeconds
	 * @summary returns the current time in seconds
	 * @return {number} The current time in seconds
	 * @private
	 */
	__getTimeInSeconds() {
		return (new Date()).getTime() / 1000;
	}

	/**
	 * @function __rootQueryPath
	 * @summary returns the root path to the Kyruus api
	 * @return {string} The root query path to Kyruus
	 * @private
	 */
	__rootQueryPath() {
		return `/pm/${this.version}/${this.source}/`;
	}



	/**
	 * @function getProviderByNpi
	 * @summary return a kyruus doctor object searched by npi
	 * @param {number} npi - The doctor's npi
	 * @return {Promise.<KyruusProvider, Object>|*}
	 * Deprecated
	 */
	getProviderByNpi(npi) {
		return this.search('filter=npi:' + encodeURIComponent(npi)).then(result => {
			// This doctor only ever be absent if the npi does not map to a doctor
			return _.get(result, 'providers[0]', null);
		});
	}

	/**
	 * @function getAllFacets
	 * @summary returns all facet objects from kyruus for an empty search
	 * @return {Promise.<KyruusFacet[]>|*}
	 */
	getAllFacets() {
		return this.search().then(result => {
			return result.facets;
		});
	}

	/**
	 * @function searchByLocation
	 * @summary Returns a list of providers, facets, suggesters, etc within the given distance of a given location
	 * @param {string|number} location - Location to search against. Either "city, state" or zipcode
	 * @param {number} distance - Filter Boundary for how far a doctor can be from the location
	 * @return {Promise.<KyruusProviderSearch>|*}
	 */
	searchByLocation(location, distance) {
		return this.search(`location=${encodeURIComponent(location)}&distance=${encodeURIComponent(distance)}`);
	}

	/**
	 * @function suggest
	 * @summary Returns a list of suggestions generated by the kyruus suggesters and autocompletes
	 * @param {string} suggester - Phrase to find suggestions for
	 * @param {string} [typeAheadCategory=null] - Kyruus typeahead category to search against
	 * @return {Promise.<KyruusSuggestions>|*}
	 */
	suggest(suggester, typeAheadCategory = null) {
		typeAheadCategory = (typeAheadCategory ? '&typeahead_categories=' + encodeURIComponent(typeAheadCategory) : '');

		let optionsOne = 'terms=' + encodeURIComponent(suggester) + typeAheadCategory,
			optionsTwo = 'name=' + encodeURIComponent(suggester);

		return q.all([this.search(optionsOne, 'typeahead'), this.search(optionsTwo)]).spread((autoComplete, suggestions) => {
			suggestions = suggestions.suggestions;

			// Map all KyruusTypeAhead suggestions into the KyruusSuggestions object
			for (let suggestion of autoComplete.exact.docs) {
				// For names, the value will already be the public value where as all other fields have a value field
				// used for match and a name field for public view
				let value = suggestion.content_type === 'name' ? suggestion.value : suggestion.name;

				// Merge the two result objects into one array with the KyruusSuggestions format
				if (_.get(suggestions, suggestion.content_type, false)) {
					suggestions[suggestion.content_type][0].suggestions = _.union(suggestions[suggestion.content_type][0].suggestions, [value]);
				}
				else {
					suggestions[suggestion.content_type] = [{suggestions: [value], term: suggester}];
				}
			}

			return suggestions;
		});
	}

	/**
	 * @function getPath
	 * @summary Does a generic search with the parameters provided if any
	 * @param {string} [searchString=''] searchString - encoded filter string to send to Kyruus
	 * @return {Promise.<KyruusProviderSearch>|*}
	 */
	getPath(searchString = '', path = 'providers') {
		return this.__rootQueryPath() + path + (searchString.length ? (searchString.charAt(0) === '?' ? searchString : '?' + searchString ) : '');
	}

	/**
	 * @function search
	 * @summary Does a generic search with the parameters provided if any
	 * @param {string} [searchString=''] searchString - encoded filter string to send to Kyruus
	 * @return {Promise.<KyruusProviderSearch>|*}
	 */
	search(searchString = '', path = 'providers') {
		if(typeof(searchString) !== 'string' ) {
			searchString = `${searchString}`;
		}
		let options = {
			hostname: this.endpoint,
			path: this.getPath(searchString, path)
		};
		return this._refreshToken().then(() => this._https(this._generateDefaultOptions(options)));
	}

	/**
	 * @function query
	 * @summary returns a new query builder to start using
	 * @return {k}
	 */
	 query() {
		 return new k(this);
	 }

	/**
	 * @function _refreshToken
	 * @summary Checks to see if there is a valid access token, and if there isn't return a promise
	 * that gets a new access token
	 * @return {promise}
	 * @private
	 */
	_refreshToken() {
		if (this._expiresAt >= this.__getTimeInSeconds() - 60 && this._token !== undefined && this._refreshTokenLock) {
			return this._refreshTokenLock;
		}
		else if (this._token === null && this._refreshTokenLock) {
			return this._refreshTokenLock;
		}

		this._token = null;

		let separator = `-----WebKitFormBoundary${crypto.randomBytes(7).toString('hex')}`;

		let options = {
			"method": "POST",
			"hostname": this.endpoint,
			"port": null,
			"path": "/oauth2/token",
			"headers": {
				"content-type": "multipart/form-data; boundary=" + separator,
				"cache-control": "no-cache"
			}};

		separator = '--' + separator;

		// This is the body of the form request Kyruus uses to login
		let body = separator + "\r\nContent-Disposition: form-data; name=\"client_id\"\r\n\r\n" + this._userName + "\r\n"
			 + separator + "\r\nContent-Disposition: form-data; name=\"client_secret\"\r\n\r\n" + this._userPassword + "\r\n"
			 + separator + "\r\nContent-Disposition: form-data; name=\"grant_type\"\r\n\r\nclient_credentials\r\n"
			 + separator + "--";

		return this._refreshTokenLock = this._https(options, body).then(result => {
			this._token = result;

			// Set the new session expiration timestamp
			this._expiresAt = this.__getTimeInSeconds() + (_.get(result, 'expires_in', 0));

			return q(result);
		});
	}

	/**
	 * @function _generateDefaultOptions
	 * @summary return an options object with enough information to return a 0 filter query on Kyruus
	 * @param {Object} [options={}] options - http request options to check data for default values
	 * @return {DefaultSearchOptions}
	 * @private
	 */
	_generateDefaultOptions(options={}) {
		options.hostname = options.hostname || this.endpoint;
		options.port = options.port || 443;
		options.method = options.method || 'GET';

		if (this._token) {
			if (!options.headers) {
				options.headers = {};
			}
			options.headers.Authorization = options.headers.Authorization || `${this._token.token_type} ${this._token.access_token}`;
		}

		return options;
	}

	/**
	 * @function _https
	 * @summary Wraps an https request using the given options within a promise
	 * @param options
	 * @return {promise|d.promise|*|r.promise}
	 * @private
	 */
	_https(options, body) {
		return q.Promise((resolve, reject) => {
			let req = https.request(options, res => {
				let str = '';

				// Another chunk of data has been received, so append it to 'str'
				res.on('data', function (chunk) {
					str += chunk;
				})
					.on('end', function () {
						if (res.statusCode >= 400) {
							return reject({status: res.statusCode, message: res.statusMessage || str});
						}
						let result = {};

						try {
							result = JSON.parse(str);

						} catch (e) {
							return reject(e);
						}

						return resolve(result);
					})
					.on('error', function (e) {
						return reject(e);
					});
			});

			req.on('error', function (e) {
				return reject(e);
			});

			if (body) {
				if (typeof body !== 'string') {
					body = JSON.stringify(body);
				}

				req.write(body);
			}

			req.end();
		});
	}
}

module.exports = Kyruus;
