'use strict';
const https = require('https'),
    crypto = require('crypto'),
    q = require('q'),
    _ = require('lodash');

class Kyruus {
    get version() {
        return 'v8';
    }

    constructor(endpoint = '', source = '', user = '', password = '') {
        this.endpoint = endpoint;
        this.source = source;
        this._userName = user;
        this._userPassword = password;
        this._token = undefined;
        this._expiresAt = 0;
        this._refreshTokenLock = null;
    }

    /**
     * @function __getTimeInSeconds
     * @summary returns the current time in seconds
     * @return {number}
     * @private
     */
    __getTimeInSeconds() {
        return (new Date()).getTime() / 1000;
    }

    /**
     * @function __rootPath
     * @summary returns the root path to the Kyruus api
     * @return {string}
     * @private
     */
    __rootPath() {
        return `/pm/${this.version}/${this.source}/`;
    }

    /**
     * @function getDoctorByNpi
     * @summary return a kyruus doctor object searched by npi
     * @param npi
     * @return {Promise.<TResult>|*}
     */
    getDoctorByNpi(npi) {
        return this.search('npi=' + encodeURIComponent(npi)).then(result => {
            // This doctor only ever be absent if the npi does not map to a doctor
            return _.get(result, 'providers[0]', q.reject({status: 404, message: 'NPI does not map to a doctor'}));
        });
    }

    /**
     * @function getAllFacets
     * @summary returns all facet objects from kyruus for an empty search
     * @return {Promise.<TResult>|*}
     */
    getAllFacets() {
        return this.search().then(result => {
            return result.facets;
        });
    }

    /**
     * @function searchByLocation
     * @summary Returns a list of providers, facets, suggesters, etc within the given distance of a given location
     * @param location
     * @param distance
     * @return {Promise.<TResult>|*}
     */
    searchByLocation(location, distance) {
        return this.search(`location=${encodeURIComponent(location)}&distance=${encodeURIComponent(distance)}`);
    }

    /**
     * @function suggest
     * @summary Returns a list of suggestions generated by the kyruus suggesters and autocompletes
     * @param suggester
     * @param typeAheadCategory
     * @return {Function|*}
     */
    suggest(suggester, typeAheadCategory = null) {
        typeAheadCategory = (typeAheadCategory ? '&typeahead_categories=' + encodeURIComponent(typeAheadCategory) : '');

        let optionsOne = 'terms=' + encodeURIComponent(suggester) + typeAheadCategory,
            optionsTwo = 'name=' + encodeURIComponent(suggester);

        return q.all([this.search(optionsOne, 'typeahead'), this.search(optionsTwo)]).spread((autoComplete, suggestions) => {
            suggestions = suggestions.suggestions;
            for (let suggestion of autoComplete.exact.docs) {
                // For names, the value will already be the public value where as all other fields have a value field
                // used for match and a name field for public view
                let value = suggestion.content_type === 'name' ? suggestion.value : suggestion.name;

                if (_.get(suggestions, suggestion.content_type, false)) {
                    suggestions[suggestion.content_type][0].suggestions = _.union(suggestions[suggestion.content_type][0].suggestions, [value]);
                }
                else {
                    suggestions[suggestion.content_type] = [{suggestions: [value], term: suggester}];
                }
            }

            return suggestions;
        });
    }

    /**
     * @function search
     * @summary Does a generic search with the parameters provided if any
     * @param searchString
     * @return {promise|d.promise|*|r.promise}
     */
    search(searchString = null, path = 'providers') {
        let options = {
            hostname: this.endpoint,
            path: this.__rootPath() + path + (searchString ? '?' + searchString : '')
        };

        return this._refreshToken().then(() => {return this._https(this._generateDefaultOptions(options));});
    }

    /**
     * @function _refreshToken
     * @summary Checks to see if there is a valid access token, and if there isn't return a promise
     * that gets a new access token
     * @return {promise}
     * @private
     */
    _refreshToken() {
        if (this._expiresAt >= this.__getTimeInSeconds() - 60 && this._token !== undefined && this._refreshTokenLock) {
            return this._refreshTokenLock;
        }
        else if (this._token === null && this._refreshTokenLock) {
            return this._refreshTokenLock;
        }

        this._token = null;

        let separator = `-----WebKitFormBoundary${crypto.randomBytes(7).toString('hex')}`;

        let options = {
            "method": "POST",
            "hostname": this.endpoint,
            "port": null,
            "path": "/oauth2/token",
            "headers": {
                "content-type": "multipart/form-data; boundary=" + separator,
                "cache-control": "no-cache"
            }};
        
        separator = '--' + separator;

        // This is the body of the form request Kyruus uses to login
        let body = separator + "\r\nContent-Disposition: form-data; name=\"client_id\"\r\n\r\n" + this._userName + "\r\n"
             + separator + "\r\nContent-Disposition: form-data; name=\"client_secret\"\r\n\r\n" + this._userPassword + "\r\n"
             + separator + "\r\nContent-Disposition: form-data; name=\"grant_type\"\r\n\r\nclient_credentials\r\n"
             + separator + "--";

        return this._refreshTokenLock = this._https(options, body).then(result => {
            this._token = result;

            // Set the new session expiration timestamp
            this._expiresAt = this.__getTimeInSeconds() + (_.get(result, 'expires_in', 0));

            return q(result);
        });
    }

    /**
     * @function _generateDefaultOptions
     * @summary return an options object with enough information to return a 0 filter query on Kyruus
     * @param options
     * @return {*}
     * @private
     */
    _generateDefaultOptions(options) {
        options.hostname = options.hostname || this.endpoint;
        options.port = options.port || 443;
        options.method = options.method || 'GET';

        if (this._token) {
            if (!options.headers) {
                options.headers = {};
            }
            options.headers.Authorization = options.headers.Authorization || `${this._token.token_type} ${this._token.access_token}`;
        }

        return options;
    }

    /**
     * @function _https
     * @summary Wraps an https request using the given options within a promise
     * @param options
     * @return {promise|d.promise|*|r.promise}
     * @private
     */
    _https(options, body) {
        return q.Promise((resolve, reject) => {
            let req = https.request(options, res => {
                let str = '';

                // Another chunk of data has been received, so append it to 'str'
                res.on('data', function (chunk) {
                    str += chunk;
                })
                    .on('end', function () {
                        if (res.statusCode >= 400) {
                            return reject({status: res.statusCode, message: res.statusMessage || str});
                        }
                        let result = {};

                        try {
                            result = JSON.parse(str);

                        } catch (e) {
                            return reject(e);
                        }

                        return resolve(result);
                    })
                    .on('error', function (e) {
                        return reject(e);
                    });
            });

            req.on('error', function (e) {
                return reject(e);
            });

            if (body) {
                if (typeof body !== 'string') {
                    body = JSON.stringify(body);
                }

                req.write(body);
            }

            req.end();
        });
    }
}

module.exports =  Kyruus;
